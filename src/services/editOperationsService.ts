/**
 * Edit Operations Service
 *
 * Provides a structured way to modify HTML using typed operations.
 * These operations can be generated by:
 * - AI (from LLM based on element summary)
 * - User (from interactive UI edits)
 *
 * Operations are applied using DOM manipulation for reliability.
 */

// ============================================================================
// Types
// ============================================================================

export type EditOperationType =
  | 'updateText'
  | 'updateAttribute'
  | 'removeAttribute'
  | 'updateStyle'
  | 'addClass'
  | 'removeClass'
  | 'insertElement'
  | 'removeElement'
  | 'moveElement'
  | 'wrapElement'
  | 'replaceElement'
  | 'replaceInnerHtml';

export interface BaseOperation {
  type: EditOperationType;
  selector: string;
  description?: string;
}

export interface UpdateTextOperation extends BaseOperation {
  type: 'updateText';
  newText: string;
}

export interface UpdateAttributeOperation extends BaseOperation {
  type: 'updateAttribute';
  attribute: string;
  value: string;
}

export interface RemoveAttributeOperation extends BaseOperation {
  type: 'removeAttribute';
  attribute: string;
}

export interface UpdateStyleOperation extends BaseOperation {
  type: 'updateStyle';
  styles: Record<string, string>;
}

export interface AddClassOperation extends BaseOperation {
  type: 'addClass';
  className: string;
}

export interface RemoveClassOperation extends BaseOperation {
  type: 'removeClass';
  className: string;
}

export interface InsertElementOperation extends BaseOperation {
  type: 'insertElement';
  position: 'before' | 'after' | 'prepend' | 'append';
  html: string;
}

export interface RemoveElementOperation extends BaseOperation {
  type: 'removeElement';
}

export interface MoveElementOperation extends BaseOperation {
  type: 'moveElement';
  targetSelector: string;
  position: 'before' | 'after' | 'prepend' | 'append';
}

export interface WrapElementOperation extends BaseOperation {
  type: 'wrapElement';
  wrapperHtml: string; // e.g., '<div class="wrapper"></div>'
}

export interface ReplaceElementOperation extends BaseOperation {
  type: 'replaceElement';
  html: string;
}

export interface ReplaceInnerHtmlOperation extends BaseOperation {
  type: 'replaceInnerHtml';
  html: string;
}

export type EditOperation =
  | UpdateTextOperation
  | UpdateAttributeOperation
  | RemoveAttributeOperation
  | UpdateStyleOperation
  | AddClassOperation
  | RemoveClassOperation
  | InsertElementOperation
  | RemoveElementOperation
  | MoveElementOperation
  | WrapElementOperation
  | ReplaceElementOperation
  | ReplaceInnerHtmlOperation;

export interface OperationResult {
  operation: EditOperation;
  success: boolean;
  error?: string;
  elementsAffected: number;
}

export interface ApplyOperationsResult {
  html: string;
  results: OperationResult[];
  totalOperations: number;
  successfulOperations: number;
  failedOperations: number;
}

// ============================================================================
// Operation Application
// ============================================================================

/**
 * Apply a single operation to a document
 */
function applyOperation(doc: Document, operation: EditOperation): OperationResult {
  const result: OperationResult = {
    operation,
    success: false,
    elementsAffected: 0,
  };

  try {
    // Find target element(s)
    const elements = doc.querySelectorAll(operation.selector);

    if (elements.length === 0) {
      result.error = `No elements found matching selector: ${operation.selector}`;
      return result;
    }

    // Apply operation based on type
    switch (operation.type) {
      case 'updateText': {
        elements.forEach((el) => {
          // Update text content while preserving child elements
          const textNodes = Array.from(el.childNodes).filter(
            (node) => node.nodeType === Node.TEXT_NODE
          );
          if (textNodes.length > 0) {
            textNodes[0].textContent = operation.newText;
          } else {
            // If no text nodes, prepend new text
            el.insertBefore(doc.createTextNode(operation.newText), el.firstChild);
          }
          result.elementsAffected++;
        });
        result.success = true;
        break;
      }

      case 'updateAttribute': {
        elements.forEach((el) => {
          el.setAttribute(operation.attribute, operation.value);
          result.elementsAffected++;
        });
        result.success = true;
        break;
      }

      case 'removeAttribute': {
        elements.forEach((el) => {
          el.removeAttribute(operation.attribute);
          result.elementsAffected++;
        });
        result.success = true;
        break;
      }

      case 'updateStyle': {
        elements.forEach((el) => {
          const htmlEl = el as HTMLElement;
          for (const [property, value] of Object.entries(operation.styles)) {
            htmlEl.style.setProperty(property, value);
          }
          result.elementsAffected++;
        });
        result.success = true;
        break;
      }

      case 'addClass': {
        elements.forEach((el) => {
          el.classList.add(operation.className);
          result.elementsAffected++;
        });
        result.success = true;
        break;
      }

      case 'removeClass': {
        elements.forEach((el) => {
          el.classList.remove(operation.className);
          result.elementsAffected++;
        });
        result.success = true;
        break;
      }

      case 'insertElement': {
        elements.forEach((el) => {
          const template = doc.createElement('template');
          template.innerHTML = operation.html.trim();
          const newElement = template.content.firstChild;

          if (!newElement) {
            result.error = 'Invalid HTML for insert operation';
            return;
          }

          switch (operation.position) {
            case 'before':
              el.parentNode?.insertBefore(newElement.cloneNode(true), el);
              break;
            case 'after':
              el.parentNode?.insertBefore(newElement.cloneNode(true), el.nextSibling);
              break;
            case 'prepend':
              el.insertBefore(newElement.cloneNode(true), el.firstChild);
              break;
            case 'append':
              el.appendChild(newElement.cloneNode(true));
              break;
          }
          result.elementsAffected++;
        });
        result.success = result.elementsAffected > 0;
        break;
      }

      case 'removeElement': {
        elements.forEach((el) => {
          el.parentNode?.removeChild(el);
          result.elementsAffected++;
        });
        result.success = true;
        break;
      }

      case 'moveElement': {
        const targetElements = doc.querySelectorAll(operation.targetSelector);
        if (targetElements.length === 0) {
          result.error = `No target elements found matching selector: ${operation.targetSelector}`;
          return result;
        }

        const target = targetElements[0];
        elements.forEach((el) => {
          const clone = el.cloneNode(true);
          el.parentNode?.removeChild(el);

          switch (operation.position) {
            case 'before':
              target.parentNode?.insertBefore(clone, target);
              break;
            case 'after':
              target.parentNode?.insertBefore(clone, target.nextSibling);
              break;
            case 'prepend':
              target.insertBefore(clone, target.firstChild);
              break;
            case 'append':
              target.appendChild(clone);
              break;
          }
          result.elementsAffected++;
        });
        result.success = true;
        break;
      }

      case 'wrapElement': {
        elements.forEach((el) => {
          const template = doc.createElement('template');
          template.innerHTML = operation.wrapperHtml.trim();
          const wrapper = template.content.firstChild as Element;

          if (!wrapper) {
            result.error = 'Invalid wrapper HTML';
            return;
          }

          const parent = el.parentNode;
          if (parent) {
            parent.insertBefore(wrapper.cloneNode(true), el);
            const insertedWrapper = el.previousSibling as Element;
            insertedWrapper.appendChild(el);
            result.elementsAffected++;
          }
        });
        result.success = result.elementsAffected > 0;
        break;
      }

      case 'replaceElement': {
        elements.forEach((el) => {
          const template = doc.createElement('template');
          template.innerHTML = operation.html.trim();
          const newElement = template.content.firstChild;

          if (!newElement) {
            result.error = 'Invalid replacement HTML';
            return;
          }

          el.parentNode?.replaceChild(newElement.cloneNode(true), el);
          result.elementsAffected++;
        });
        result.success = result.elementsAffected > 0;
        break;
      }

      case 'replaceInnerHtml': {
        elements.forEach((el) => {
          el.innerHTML = operation.html;
          result.elementsAffected++;
        });
        result.success = true;
        break;
      }

      default: {
        result.error = `Unknown operation type: ${(operation as EditOperation).type}`;
      }
    }
  } catch (error) {
    result.error = error instanceof Error ? error.message : 'Unknown error';
  }

  return result;
}

/**
 * Apply multiple operations to HTML
 * Operations are applied in order
 */
export function applyEditOperations(
  html: string,
  operations: EditOperation[]
): ApplyOperationsResult {
  // Parse HTML
  const parser = new DOMParser();
  const doc = parser.parseFromString(html, 'text/html');

  // Apply each operation
  const results: OperationResult[] = [];
  let successfulOperations = 0;
  let failedOperations = 0;

  for (const operation of operations) {
    const result = applyOperation(doc, operation);
    results.push(result);

    if (result.success) {
      successfulOperations++;
    } else {
      failedOperations++;
      console.warn(`[EditOperations] Operation failed:`, result.error, operation);
    }
  }

  // Serialize back to HTML
  // We need to reconstruct the full HTML including doctype
  const doctype = doc.doctype
    ? `<!DOCTYPE ${doc.doctype.name}${doc.doctype.publicId ? ` PUBLIC "${doc.doctype.publicId}"` : ''}${doc.doctype.systemId ? ` "${doc.doctype.systemId}"` : ''}>`
    : '<!DOCTYPE html>';

  const serializedHtml = `${doctype}\n${doc.documentElement.outerHTML}`;

  return {
    html: serializedHtml,
    results,
    totalOperations: operations.length,
    successfulOperations,
    failedOperations,
  };
}

// ============================================================================
// Operation Builders (for convenience)
// ============================================================================

export const EditOps = {
  updateText(selector: string, newText: string, description?: string): UpdateTextOperation {
    return { type: 'updateText', selector, newText, description };
  },

  updateAttribute(selector: string, attribute: string, value: string, description?: string): UpdateAttributeOperation {
    return { type: 'updateAttribute', selector, attribute, value, description };
  },

  removeAttribute(selector: string, attribute: string, description?: string): RemoveAttributeOperation {
    return { type: 'removeAttribute', selector, attribute, description };
  },

  updateStyle(selector: string, styles: Record<string, string>, description?: string): UpdateStyleOperation {
    return { type: 'updateStyle', selector, styles, description };
  },

  addClass(selector: string, className: string, description?: string): AddClassOperation {
    return { type: 'addClass', selector, className, description };
  },

  removeClass(selector: string, className: string, description?: string): RemoveClassOperation {
    return { type: 'removeClass', selector, className, description };
  },

  insertElement(
    selector: string,
    position: 'before' | 'after' | 'prepend' | 'append',
    html: string,
    description?: string
  ): InsertElementOperation {
    return { type: 'insertElement', selector, position, html, description };
  },

  removeElement(selector: string, description?: string): RemoveElementOperation {
    return { type: 'removeElement', selector, description };
  },

  moveElement(
    selector: string,
    targetSelector: string,
    position: 'before' | 'after' | 'prepend' | 'append',
    description?: string
  ): MoveElementOperation {
    return { type: 'moveElement', selector, targetSelector, position, description };
  },

  wrapElement(selector: string, wrapperHtml: string, description?: string): WrapElementOperation {
    return { type: 'wrapElement', selector, wrapperHtml, description };
  },

  replaceElement(selector: string, html: string, description?: string): ReplaceElementOperation {
    return { type: 'replaceElement', selector, html, description };
  },

  replaceInnerHtml(selector: string, html: string, description?: string): ReplaceInnerHtmlOperation {
    return { type: 'replaceInnerHtml', selector, html, description };
  },
};

// ============================================================================
// Validation
// ============================================================================

/**
 * Validate that operations are well-formed
 */
export function validateOperations(operations: EditOperation[]): {
  valid: boolean;
  errors: string[];
} {
  const errors: string[] = [];

  for (let i = 0; i < operations.length; i++) {
    const op = operations[i];

    // Check selector
    if (!op.selector || typeof op.selector !== 'string') {
      errors.push(`Operation ${i}: Missing or invalid selector`);
    }

    // Validate selector syntax
    try {
      document.createElement('div').querySelector(op.selector);
    } catch {
      errors.push(`Operation ${i}: Invalid CSS selector: ${op.selector}`);
    }

    // Type-specific validation
    switch (op.type) {
      case 'updateText':
        if (typeof op.newText !== 'string') {
          errors.push(`Operation ${i}: updateText requires newText string`);
        }
        break;

      case 'updateAttribute':
        if (!op.attribute || typeof op.attribute !== 'string') {
          errors.push(`Operation ${i}: updateAttribute requires attribute name`);
        }
        break;

      case 'updateStyle':
        if (!op.styles || typeof op.styles !== 'object') {
          errors.push(`Operation ${i}: updateStyle requires styles object`);
        }
        break;

      case 'insertElement':
      case 'replaceElement':
      case 'replaceInnerHtml':
        if (!op.html || typeof op.html !== 'string') {
          errors.push(`Operation ${i}: ${op.type} requires html string`);
        }
        break;

      case 'moveElement':
        if (!op.targetSelector || typeof op.targetSelector !== 'string') {
          errors.push(`Operation ${i}: moveElement requires targetSelector`);
        }
        break;

      case 'wrapElement':
        if (!op.wrapperHtml || typeof op.wrapperHtml !== 'string') {
          errors.push(`Operation ${i}: wrapElement requires wrapperHtml`);
        }
        break;
    }
  }

  return {
    valid: errors.length === 0,
    errors,
  };
}

// ============================================================================
// Parsing LLM Output
// ============================================================================

/**
 * Parse operations from LLM JSON output
 * Handles common LLM formatting issues
 */
export function parseOperationsFromLLM(llmOutput: string): EditOperation[] {
  // Try to extract JSON from the output
  let jsonStr = llmOutput;

  // Remove markdown code blocks if present
  const jsonMatch = llmOutput.match(/```(?:json)?\s*([\s\S]*?)```/);
  if (jsonMatch) {
    jsonStr = jsonMatch[1];
  }

  // Try to find JSON array
  const arrayMatch = jsonStr.match(/\[[\s\S]*\]/);
  if (arrayMatch) {
    jsonStr = arrayMatch[0];
  }

  try {
    const parsed = JSON.parse(jsonStr);

    // Handle both array and object with operations key
    const operations = Array.isArray(parsed)
      ? parsed
      : parsed.operations || parsed.edits || [];

    // Validate and filter
    return operations.filter((op: unknown) => {
      if (!op || typeof op !== 'object') return false;
      const opObj = op as Record<string, unknown>;
      return opObj.type && opObj.selector;
    }) as EditOperation[];
  } catch (error) {
    console.error('[EditOperations] Failed to parse LLM output:', error);
    return [];
  }
}

// ============================================================================
// Operation History (for undo/redo)
// ============================================================================

export interface EditHistoryEntry {
  timestamp: number;
  operations: EditOperation[];
  htmlBefore: string;
  htmlAfter: string;
  source: 'ai' | 'user';
  description?: string;
}

export class EditHistory {
  private history: EditHistoryEntry[] = [];
  private currentIndex = -1;

  push(entry: Omit<EditHistoryEntry, 'timestamp'>): void {
    // Remove any future history if we're not at the end
    if (this.currentIndex < this.history.length - 1) {
      this.history = this.history.slice(0, this.currentIndex + 1);
    }

    this.history.push({
      ...entry,
      timestamp: Date.now(),
    });
    this.currentIndex = this.history.length - 1;
  }

  canUndo(): boolean {
    return this.currentIndex >= 0;
  }

  canRedo(): boolean {
    return this.currentIndex < this.history.length - 1;
  }

  undo(): EditHistoryEntry | null {
    if (!this.canUndo()) return null;
    const entry = this.history[this.currentIndex];
    this.currentIndex--;
    return entry;
  }

  redo(): EditHistoryEntry | null {
    if (!this.canRedo()) return null;
    this.currentIndex++;
    return this.history[this.currentIndex];
  }

  getCurrentHtml(): string | null {
    if (this.currentIndex < 0) return null;
    return this.history[this.currentIndex].htmlAfter;
  }

  getHistory(): EditHistoryEntry[] {
    return [...this.history];
  }

  clear(): void {
    this.history = [];
    this.currentIndex = -1;
  }
}
